using System;
using System.Collections.Generic;
using WillyNilly.Variables;

namespace WillyNilly
{
    public class VariableFactory
    {
        public VariableFactory() : this(new DefaultUniformRandomSource()) { }

        public VariableFactory(IRandomSource source)
        {
            Source = source ?? throw new ArgumentNullException(nameof(source));
        }

        public IRandomSource Source { get; }

        /// <summary>
        /// Returns an element from the input array in uniform distribution.
        /// </summary>
        public IRandomVariable<T> ArrayUniform<T>(T[] members)
            => new ArrayUniformVariable<T>(Source, members);

        /// <summary>
        /// Returns true and false in equal measures.
        /// </summary>
        public IRandomVariable<bool> Boolean()
            => new BooleanVariable(Source, 0.5);

        /// <summary>
        /// Creates a variable which returns true with the specified probability.
        /// </summary>
        /// <param name="prob">A number between 0 and 1, representing the probability of the measuring true.</param>
        public IRandomVariable<bool> Boolean(double prob)
            => new BooleanVariable(Source, prob);

        /// <summary>
        /// Returns a constant value.
        /// </summary>
        /// <param name="value">The value to return.</param>
        public IRandomVariable<T> Constant<T>(T value)
            => new ConstantVariable<T>(value);

        /// <summary>
        /// Returns dates within the specified range.
        /// </summary>
        public IRandomVariable<DateTime> DateTime(DateTime min, DateTime max)
            => new DateTimeVariable(Source, min, max);

        /// <summary>
        /// Returns doubles in gaussian distribution.
        /// </summary>
        public IRandomVariable<double> DoubleGaussian(double mean, double sigma)
            => new DoubleGaussianVariable(Source, mean, sigma);

        /// <summary>
        /// Returns doubles in uniform distribution
        /// </summary>
        public IRandomVariable<double> DoubleUniform(double min, double max)
            => new DoubleUniformVariable(Source, min, max);

        /// <summary>
        /// Returns the declared values of an enum with uniform probability.
        /// </summary>
        public IRandomVariable<T> Enum<T>() where T : struct
            => new EnumVariable<T>(Source);

        /// <summary>
        /// Returns floats in uniform distribution
        /// </summary>
        public IRandomVariable<float> FloatUniform(float min, float max)
            => new FloatUniformVariable(Source, min, max);

        /// <summary>
        /// Returns the element generated by an input function.
        /// </summary>
        public IRandomVariable<T> Func<T>(Func<T> f)
            => new FuncVariable<T>(f);

        /// <summary>
        /// Groups multiple variables to be measured together.
        /// </summary>
        public IRandomVariable<(T1, T2)> Group<T1, T2>(IRandomVariable<T1> a, IRandomVariable<T2> b)
            => new GroupVariables<T1, T2>(a, b);

        /// <summary>
        /// Groups multiple variables to be measured together.
        /// </summary>
        public IRandomVariable<(T1, T2, T3)> Group<T1, T2, T3>(IRandomVariable<T1> a, IRandomVariable<T2> b, IRandomVariable<T3> c)
            => new GroupVariables<T1, T2, T3>(a, b, c);

        /// <summary>
        /// Returns integers in uniform distribution.
        /// </summary>
        public IRandomVariable<int> IntUniform(int min, int max)
            => new IntUniformVariable(Source, min, max);

        /// <summary>
        /// Applies a mapping on the output of one random variable to produce another.
        /// </summary>
        public IRandomVariable<TOut> Map<TIn, TOut>(IRandomVariable<TIn> input, Func<TIn, TOut> func)
            => new MapVariable<TIn, TOut>(input, func);

        /// <summary>
        /// Returns a value from any one of the input variables,
        /// choosing from them with uniform distribution.
        /// </summary>
        public IRandomVariable<T> Or<T>(IRandomVariable<T>[] inputs)
            => new OrVariable<T>(Source, inputs);

        /// <summary>
        /// Returns a value from any one of the input variables,
        /// choosing from them with uniform distribution.
        /// </summary>
        public IRandomVariable<T> Or<T>(IRandomVariable<T> a, IRandomVariable<T> b)
            => new OrVariable<T>(Source, new[] { a, b });

        /// <summary>
        /// Returns a value from any one of the input variables,
        /// choosing from them with uniform distribution.
        /// </summary>
        public IRandomVariable<T> Or<T>(IRandomVariable<T> a, IRandomVariable<T> b, IRandomVariable<T> c)
            => new OrVariable<T>(Source, new[] { a, b, c });

        /// <summary>
        /// Returns elements sequentially from an infinite sequence.
        /// </summary>
        public IRandomVariable<T> Sequence<T>(IEnumerable<T> sequence)
            => new SequenceVariable<T>(sequence);

    }
}
